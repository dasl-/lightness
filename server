#!/usr/bin/python3
from http.server import HTTPServer, BaseHTTPRequestHandler, HTTPStatus
from io import BytesIO
import json
import subprocess
import ssl
from lightness.db import DB
from lightness.logger import Logger
from lightness.config import Config
from lightness.directoryutils import DirectoryUtils

class LightnessAPI():
    __db = DB()

    def get_queue(self):
        response_details = {}
        queue = self.__db.getQueue()
        response_details['queue'] = queue
        response_details['success'] = True
        return response_details

    def enqueue(self, post_data):
        url = post_data['url']
        color_mode = post_data['color_mode']
        thumbnail = post_data['thumbnail']
        title = post_data['title']

        response_details = {}
        response_details['url'] = url
        response_details['color_mode'] = color_mode
        response_details['thumbnail'] = thumbnail
        response_details['title'] = title

        self.__db.enqueue(url, color_mode, thumbnail, title)

        response_details['success'] = True
        return response_details

    def skip(self):
        self.__db.skip()

        response_details = {}
        response_details['success'] = True
        return response_details

    def clear(self):
        self.__db.clear()

        response_details = {}
        response_details['success'] = True
        return response_details

class LightnessServerRequestHandler(BaseHTTPRequestHandler):

    __root_dir = None
    __api = None
    __logger = None

    def __init__(self, request, client_address, server):
        self.__root_dir = DirectoryUtils().root_dir + "/app/build"
        self.__api = LightnessAPI()
        self.__logger = Logger().set_namespace(self.__class__.__name__)
        BaseHTTPRequestHandler.__init__(self, request, client_address, server)

    def do_OPTIONS(self):
        self.send_response(200, "ok")
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header("Access-Control-Allow-Headers", "X-Requested-With")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

    def do_GET(self):
        try:
            if self.path[:4] == "/api":
                return self.__do_api_GET(self.path[5:])

            return self.__serve_static_asset()
        except Exception as e:
            self.log_error('Exception: ' + str(e))

    def do_POST(self):
        try:
            if self.path[:4] == "/api":
                return self.__do_api_POST(self.path[5:])

            return self.__serve_static_asset()
        except Exception as e:
            self.log_error('Exception: ' + str(e))

    def __do_404(self):
        self.send_response(404)
        self.end_headers()

    def __do_api_GET(self, path):
        if path == 'queue':
            response = self.__api.get_queue()
        else:
            self.__do_404()
            return

        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        resp = BytesIO()
        resp.write(bytes(json.dumps(response), 'utf-8'))
        self.wfile.write(resp.getvalue())

    def __do_api_POST(self, path):
        content_length = int(self.headers['Content-Length'])

        if content_length > 0:
            body = self.rfile.read(content_length)
            post_data = json.loads(body.decode("utf-8"))

        if path == 'queue':
            response = self.__api.enqueue(post_data)
        elif path == 'skip':
            response = self.__api.skip()
        elif path == 'clear':
            response = self.__api.clear()
        else:
            self.__do_404()
            return

        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        resp = BytesIO()
        resp.write(bytes(json.dumps(response), 'utf-8'))
        self.wfile.write(resp.getvalue())

    def __serve_static_asset(self):
        if self.path == '/':
            self.path = '/index.html'

        self.path = self.__root_dir + self.path

        try:
            file_to_open = open(self.path, 'rb').read()
            self.send_response(200)
        except Exception as e:
            self.__logger.error(str(e))
            file_to_open = "File not found"
            self.__do_404()
            return

        self.end_headers()

        if type(file_to_open) is bytes:
            self.wfile.write(file_to_open)
        else:
            self.wfile.write(bytes(file_to_open, 'utf-8'))
        return

    def log_request(self, code='-', size='-'):
        if isinstance(code, HTTPStatus):
            code = code.value
        self.log_message('[REQUEST] "%s" %s %s', self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        self.__logger.error("%s - - [%s] %s" % (self.client_address[0], self.log_date_time_string(), format%args))

    def log_message(self, format, *args):
        self.__logger.info("%s - - [%s] %s" % (self.client_address[0], self.log_date_time_string(), format%args))


class LightnessServer:

    __secure = False
    __server = None
    __config = Config()

    def __init__(self):
        self.__secure = self.__config.get_server_config('use_ssl', False)

        if not self.__secure:
            self.__server = HTTPServer(('0.0.0.0', 80), LightnessServerRequestHandler)
        else:
            self.__server = HTTPServer(('0.0.0.0', 443), LightnessServerRequestHandler)
            self.__server.socket = ssl.wrap_socket(self.__server.socket,
                                                   keyfile=self.__config.get_server_config('keyfile', ""),
                                                   certfile=self.__config.get_server_config('certfile', ""),
                                                   server_side=True)

    def serve_forever(self):
        self.__server.serve_forever()

server = LightnessServer()
server.serve_forever()
