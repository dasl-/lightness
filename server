#!/usr/bin/python3
from http.server import HTTPServer, BaseHTTPRequestHandler, HTTPStatus
from io import BytesIO
import json
import subprocess
import ssl
import sqlite3
from pathlib import Path
from pifi.playlist import Playlist
from pifi.logger import Logger
from pifi.config import Config
from pifi.directoryutils import DirectoryUtils
from pifi.volumecontroller import VolumeController
from pifi.games.snake import Snake

class PifiAPI():
    __playlist = None
    __vol_controller = None
    __cursor = None
    __logger = None

    def __init__(self):
        self.__playlist = Playlist()
        self.__vol_controller = VolumeController()
        self.__snake_db_cursor = sqlite3.connect(Snake.DB_PATH, isolation_level = None).cursor()
        self.__logger = Logger().set_namespace(self.__class__.__name__)

    def get_queue(self):
        response_details = {}
        queue = self.__playlist.get_queue()
        response_details['queue'] = queue
        response_details['vol_pct'] = self.__vol_controller.get_vol_pct()
        response_details['success'] = True
        return response_details

    def enqueue(self, post_data):
        self.__playlist.enqueue(
            post_data['url'], post_data['color_mode'], post_data['thumbnail'], post_data['title'], post_data['duration']
        )
        response_details = post_data
        response_details['success'] = True
        return response_details

    def skip(self, post_data):
        self.__playlist.skip(post_data['playlist_video_id'])

        response_details = {}
        response_details['success'] = True
        return response_details

    def remove(self, post_data):
        # todo: if you remove the current video it should be equivalent to a skip, currently it is not
        self.__playlist.remove(post_data['playlist_video_id'])

        response_details = {}
        response_details['success'] = True
        return response_details

    def clear(self):
        self.__playlist.clear()

        response_details = {}
        response_details['success'] = True
        return response_details

    def set_vol_pct(self, post_data):
        vol_pct = int(post_data['vol_pct'])
        self.__vol_controller.set_vol_pct(vol_pct)
        return {
            'vol_pct': vol_pct,
            'success': True
        }

    def snake_move(self, post_data):
        move = int(post_data['move'])
        response_details = {}
        if move == Snake.UP or move == Snake.DOWN or move == Snake.LEFT or move == Snake.RIGHT:
            self.__snake_db_cursor.execute("INSERT INTO snake_moves (move) VALUES (?)", [move])
            response_details['success'] = True
        else:
            response_details['success'] = False
        return response_details

    def snake_new_game(self, post_data):
        response_details = {}
        try:
            Path(Snake.LOCK_FILE).touch(exist_ok = False)
        except FileExistsError as e:
            response_details['success'] = False
        else:
            response_details['success'] = True
        return response_details

class PifiServerRequestHandler(BaseHTTPRequestHandler):

    __root_dir = None
    __api = None
    __logger = None

    def __init__(self, request, client_address, server):
        self.__root_dir = DirectoryUtils().root_dir + "/app/build"
        self.__api = PifiAPI()
        self.__logger = Logger().set_namespace(self.__class__.__name__)
        BaseHTTPRequestHandler.__init__(self, request, client_address, server)

    def do_OPTIONS(self):
        self.send_response(200, "ok")
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header("Access-Control-Allow-Headers", "X-Requested-With")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

    def do_GET(self):
        try:
            if self.path[:4] == "/api":
                return self.__do_api_GET(self.path[5:])

            return self.__serve_static_asset()
        except Exception as e:
            self.log_error('Exception: ' + str(e))

    def do_POST(self):
        try:
            if self.path[:4] == "/api":
                return self.__do_api_POST(self.path[5:])

            return self.__serve_static_asset()
        except Exception as e:
            self.log_error('Exception: ' + str(e))

    def __do_404(self):
        self.send_response(404)
        self.end_headers()

    def __do_api_GET(self, path):
        if path == 'queue':
            response = self.__api.get_queue()
        else:
            self.__do_404()
            return

        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        resp = BytesIO()
        resp.write(bytes(json.dumps(response), 'utf-8'))
        self.wfile.write(resp.getvalue())

    def __do_api_POST(self, path):
        content_length = int(self.headers['Content-Length'])

        post_data = None
        if content_length > 0:
            body = self.rfile.read(content_length)
            post_data = json.loads(body.decode("utf-8"))

        if path == 'queue':
            response = self.__api.enqueue(post_data)
        elif path == 'skip':
            response = self.__api.skip(post_data)
        elif path == 'remove':
            response = self.__api.remove(post_data)
        elif path == 'clear':
            response = self.__api.clear()
        elif path == 'vol_pct':
            response = self.__api.set_vol_pct(post_data)
        elif path == 'snake_move':
            response = self.__api.snake_move(post_data)
        elif path == 'snake_new_game':
            response = self.__api.snake_new_game(post_data)
        else:
            self.__do_404()
            return

        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        resp = BytesIO()
        resp.write(bytes(json.dumps(response), 'utf-8'))
        self.wfile.write(resp.getvalue())

    def __serve_static_asset(self):
        if self.path == '/':
            self.path = '/index.html'

        if self.path == '/snake' or self.path == '/snake/':
            self.path = DirectoryUtils().root_dir + '/snake.html'
        elif self.path == '/snake.gif' or self.path == '/snake-active.gif':
            self.path = DirectoryUtils().root_dir + self.path
        else:
            self.path = self.__root_dir + self.path

        try:
            file_to_open = open(self.path, 'rb').read()
            self.send_response(200)
        except Exception as e:
            self.__logger.error(str(e))
            file_to_open = "File not found"
            self.__do_404()
            return

        self.end_headers()

        if type(file_to_open) is bytes:
            self.wfile.write(file_to_open)
        else:
            self.wfile.write(bytes(file_to_open, 'utf-8'))
        return

    def log_request(self, code='-', size='-'):
        if isinstance(code, HTTPStatus):
            code = code.value
        self.log_message('[REQUEST] "%s" %s %s', self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        self.__logger.error("%s - - [%s] %s" % (self.client_address[0], self.log_date_time_string(), format%args))

    def log_message(self, format, *args):
        self.__logger.info("%s - - [%s] %s" % (self.client_address[0], self.log_date_time_string(), format%args))


class PifiServer:

    __secure = False
    __server = None
    __config = Config()

    def __init__(self):
        self.__secure = self.__config.get_server_config('use_ssl', False)

        if not self.__secure:
            self.__server = HTTPServer(('0.0.0.0', 80), PifiServerRequestHandler)
        else:
            self.__server = HTTPServer(('0.0.0.0', 443), PifiServerRequestHandler)
            self.__server.socket = ssl.wrap_socket(self.__server.socket,
                                                   keyfile=self.__config.get_server_config('keyfile', ""),
                                                   certfile=self.__config.get_server_config('certfile', ""),
                                                   server_side=True)

    def serve_forever(self):
        self.__server.serve_forever()

server = PifiServer()
server.serve_forever()
