#!/usr/bin/python3
from http.server import HTTPServer, BaseHTTPRequestHandler, HTTPStatus
from io import BytesIO
import json
import subprocess
import ssl
import sqlite3
import traceback
from pathlib import Path
from pifi.playlist import Playlist
from pifi.logger import Logger
from pifi.config import Config
from pifi.directoryutils import DirectoryUtils
from pifi.volumecontroller import VolumeController
from pifi.games.gamecolorhelper import GameColorHelper
from pifi.settings.snakesettings import SnakeSettings

class PifiAPI():
    __playlist = None
    __vol_controller = None
    __logger = None

    def __init__(self):
        self.__playlist = Playlist()
        self.__vol_controller = VolumeController()
        self.__logger = Logger().set_namespace(self.__class__.__name__)

    def get_queue(self):
        response_details = {}
        queue = self.__playlist.get_queue()
        response_details['queue'] = queue
        response_details['vol_pct'] = self.__vol_controller.get_vol_pct()
        response_details['success'] = True
        return response_details

    def enqueue(self, post_data):
        self.__playlist.enqueue(
            post_data['url'], post_data['color_mode'], post_data['thumbnail'], post_data['title'], post_data['duration'], Playlist.TYPE_VIDEO, ''
        )
        response_details = post_data
        response_details['success'] = True
        return response_details

    def enqueue_game(self, post_data):
        game_type = Playlist.TYPE_GAME
        url = None
        color_mode = GameColorHelper.GAME_COLOR_MODE_RANDOM
        thumbnail = '/assets/snake/snake-thumbnail.png'
        title = post_data['title']
        difficulty = int(post_data['difficulty'])
        if difficulty < 0 or difficulty > 9:
            difficulty = SnakeSettings.DEFAULT_DIFFICULTY
        settings = json.dumps({ 'difficulty': difficulty })
        duration = 'n/a'
        game_playlist_video_id = self.__playlist.enqueue(
            url, color_mode, thumbnail, title, duration, game_type, settings
        )

        # skip videos in the queue until we get to the game
        while True:
            current_video = self.__playlist.get_current_video()
            if current_video is None:
                break
            if current_video['playlist_video_id'] < game_playlist_video_id:
                self.__playlist.skip(current_video['playlist_video_id'])
            else:
                break

        response_details = {}
        response_details['success'] = True
        return response_details

    def skip(self, post_data):
        success = self.__playlist.skip(post_data['playlist_video_id'])

        response_details = {}
        response_details['success'] = success
        return response_details

    def remove(self, post_data):
        success = self.__playlist.remove(post_data['playlist_video_id'])

        response_details = {}
        response_details['success'] = success
        return response_details

    def clear(self):
        self.__playlist.clear()

        response_details = {}
        response_details['success'] = True
        return response_details

    def set_vol_pct(self, post_data):
        vol_pct = int(post_data['vol_pct'])
        self.__vol_controller.set_vol_pct(vol_pct)
        return {
            'vol_pct': vol_pct,
            'success': True
        }

class PifiServerRequestHandler(BaseHTTPRequestHandler):

    __root_dir = None
    __api = None
    __logger = None

    def __init__(self, request, client_address, server):
        self.__root_dir = DirectoryUtils().root_dir + "/app/build"
        self.__api = PifiAPI()
        self.__logger = Logger().set_namespace(self.__class__.__name__)
        BaseHTTPRequestHandler.__init__(self, request, client_address, server)

    def do_OPTIONS(self):
        self.send_response(200, "ok")
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header("Access-Control-Allow-Headers", "X-Requested-With")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

    def do_GET(self):
        try:
            if self.path[:4] == "/api":
                return self.__do_api_GET(self.path[5:])

            return self.__serve_static_asset()
        except Exception as e:
            self.log_error('Exception: {}'.format(traceback.format_exc()))

    def do_POST(self):
        try:
            if self.path[:4] == "/api":
                return self.__do_api_POST(self.path[5:])
            return self.__serve_static_asset()
        except Exception as e:
            self.log_error('Exception: {}'.format(traceback.format_exc()))

    def __do_404(self):
        self.send_response(404)
        self.end_headers()

    def __do_api_GET(self, path):
        if path == 'queue':
            response = self.__api.get_queue()
        else:
            self.__do_404()
            return

        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        resp = BytesIO()
        resp.write(bytes(json.dumps(response), 'utf-8'))
        self.wfile.write(resp.getvalue())

    def __do_api_POST(self, path):
        content_length = int(self.headers['Content-Length'])

        post_data = None
        if content_length > 0:
            body = self.rfile.read(content_length)
            post_data = json.loads(body.decode("utf-8"))

        if path == 'queue':
            response = self.__api.enqueue(post_data)
        elif path == 'skip':
            response = self.__api.skip(post_data)
        elif path == 'remove':
            response = self.__api.remove(post_data)
        elif path == 'clear':
            response = self.__api.clear()
        elif path == 'vol_pct':
            response = self.__api.set_vol_pct(post_data)
        elif path == 'enqueue_game':
            response = self.__api.enqueue_game(post_data)
        else:
            self.__do_404()
            return

        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        resp = BytesIO()
        resp.write(bytes(json.dumps(response), 'utf-8'))
        self.wfile.write(resp.getvalue())

    def __serve_static_asset(self):
        if self.path == '/':
            self.path = '/index.html'

        if self.path == '/snake' or self.path == '/snake/':
            self.path = DirectoryUtils().root_dir + '/assets/snake/snake.html'
        elif self.path.startswith('/assets/'):
            self.path = DirectoryUtils().root_dir + '/assets/' + self.path[len('/assets/'):]
        else:
            self.path = self.__root_dir + self.path

        try:
            file_to_open = open(self.path, 'rb').read()
            self.send_response(200)
        except Exception as e:
            self.__logger.error(str(e))
            self.log_error('Exception: {}'.format(traceback.format_exc()))
            file_to_open = "File not found"
            self.__do_404()
            return

        self.end_headers()

        if type(file_to_open) is bytes:
            self.wfile.write(file_to_open)
        else:
            self.wfile.write(bytes(file_to_open, 'utf-8'))
        return

    def log_request(self, code='-', size='-'):
        if isinstance(code, HTTPStatus):
            code = code.value
        self.log_message('[REQUEST] "%s" %s %s', self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        self.__logger.error("%s - - %s" % (self.client_address[0], format%args))

    def log_message(self, format, *args):
        self.__logger.info("%s - - %s" % (self.client_address[0], format%args))


class PifiServer:

    __secure = False
    __server = None
    __config = Config()

    def __init__(self):
        self.__secure = self.__config.get_server_config('use_ssl', False)

        if not self.__secure:
            self.__server = HTTPServer(('0.0.0.0', 80), PifiServerRequestHandler)
        else:
            self.__server = HTTPServer(('0.0.0.0', 443), PifiServerRequestHandler)
            self.__server.socket = ssl.wrap_socket(self.__server.socket,
                                                   keyfile=self.__config.get_server_config('keyfile', ""),
                                                   certfile=self.__config.get_server_config('certfile', ""),
                                                   server_side=True)

    def serve_forever(self):
        self.__server.serve_forever()

server = PifiServer()
server.serve_forever()
